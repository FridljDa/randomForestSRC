---
title: "IHW simple Benchmark"
output: html_document
---


Loading packages.
```{r setup, message = F}
library(magrittr)
library(dplyr)
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE)
set.seed(1234)
theme_set(theme_bw())
```

```{r}
m <- 400
#nfolds <- 3
#folds <- sample(1:nfolds, m, replace = TRUE)

cov1 <- runif(m, -1, 1)
cov2 <- runif(m, -1, 1)
prop_alt <- 1 / (1 + exp(-1 * (3 * cov1 + 2 * cov2 - 5)))
pvalues <- ifelse(rbinom(m, size = 1, prop_alt),
  rbeta(m, 0.25, 1),
  runif(m)
)
covariates <- cbind(cov1, cov2)

tau <- 0.5

data <- data.frame(
        indic = (pvalues >= tau) / (1 - tau),
        covariates
      )
```

```{r}
library(randomForestSRC)
# New York air quality measurements. Mean ozone in parts per billion.
res <- rfsrc(indic ~ cov1 + cov2, data = data)
#, nsplit = 10
res
#res$leaf.count	
#res$var.used
#res$split.depth
#get.mv.formula
```

```{r}
var.used <- predict(res, var.used = "by.tree")$var.used
```

```{r}
res_pred <- stats::predict(res, data[, c("cov1","cov2")], membership = T)
#res_pred$predicted
```

```{r}
str(res_pred$y)
```

```{r}
groups <- res_pred$membership
str(groups)
```

```{r}
## motor trend cars
mtcars.obj <- rfsrc(mpg ~ ., data = mtcars, splitrule = "custom")
## iris analysis
iris.obj <- rfsrc(Species ~., data = iris, splitrule = "custom1")
```

```{r}
#' @importFrom randomForestSRC rfsrc
group_by_forest_BocaLeek <- function(pvalues, covariates, folds, nbins, ntrees, taus = NULL, ntaus =5, maxdepth = NULL, min.node.size = NULL, seed = NULL) {
  m <- length(pvalues)
  # calculate parameters for forest
  if(is.null(maxdepth)){
    maxdepth <- log2(nbins) # TODO should depend on nvar
    maxdepth <- ceiling(maxdepth)
  }
  #maxdepth <- 2 #TODO
  # min.node.size <- 2^(maxdepth+1)-1 #TODO
  if(is.null(min.node.size)) min.node.size <- floor(0.9 * (m / 8))
  
  if(is.null(ntaus)) ntaus <- length(taus) 
  taus_specified <- !is.null(taus)
  mtry <- ceiling(0.9 * ncol(covariates))  # a lot of noise data => high mtry
  
  groups <- matrix(0, nrow = m, ncol = as.numeric(ntrees * ntaus))
  
  for (i in unique(folds)) {
    pvalues_other_folds <- pvalues[folds != i]
    if(!taus_specified){
      quantile_seq <- seq(0, 1, length.out = ntaus+2)[2:(ntaus+1)]
      taus <- quantile(pvalues_other_folds, quantile_seq)
    } 
    for (j in seq_along(taus)) {
      tau <- taus[j]
      # binary indicator from Boca and leek/storey
      data <- data.frame(
        indic = (pvalues >= tau) / (1 - tau),
        covariates,
        folds
      )
      
      data_holdout_fold <- data[folds == i, -"indic"]
      data_other_folds <- data[folds != i, ]

      
      # build forest based on other folds
      forest_other_fold <- randomForestSRC::rfsrc(
            indic ~ . - folds - indic,
            data = data_other_folds,
            ntree = ntrees,
            mtry = mtry,
            nodesize = min.node.size,
            nodedepth = maxdepth,
            splitrule = "mse",
            nsplit = nsplit,
            block.size = F,
            forest.wt = F,
            seed = seed)

      #useful diagnostic var.used <- predict(res, var.used = "by.tree")$var.used
      # predict terminal nodes of holdout_fold
      predict_groups <- randomForestSRC::predict(forest_other_fold, data_holdout_fold, membership = T)
      groups[folds == i, (j - 1) * ntrees + seq_len(ntrees)] <- predict_groups$membership
    }
  }
  groups <- as.data.frame(groups)
  groups[] <- lapply(groups, as.factor)
  colnames(groups) <- paste0("group", seq_along(groups))
  return(groups)
}
```

